// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate with the admin server.
	// (POST /client/auth)
	Authenticate(ctx echo.Context) error
	// Get all feature flags activations
	// (GET /client/env/{environmentUUID}/feature-configs)
	GetFeatureConfig(ctx echo.Context, environmentUUID string) error
	// Get feature config
	// (GET /client/env/{environmentUUID}/feature-configs/{identifier})
	GetFeatureConfigByIdentifier(ctx echo.Context, environmentUUID string, identifier string) error
	// Retrieve all segments.
	// (GET /client/env/{environmentUUID}/target-segments)
	GetAllSegments(ctx echo.Context, environmentUUID string) error
	// Retrieve a segment by identifier
	// (GET /client/env/{environmentUUID}/target-segments/{identifier})
	GetSegmentByIdentifier(ctx echo.Context, environmentUUID string, identifier string) error
	// Get feature evaluations for target
	// (GET /client/env/{environmentUUID}/target/{target}/evaluations)
	GetEvaluations(ctx echo.Context, environmentUUID string, target string) error
	// Get feature evaluations for target
	// (GET /client/env/{environmentUUID}/target/{target}/evaluations/{feature})
	GetEvaluationByIdentifier(ctx echo.Context, environmentUUID string, target string, feature string) error
	// Send metrics to the Analytics server.
	// (POST /metrics/{environment})
	PostMetrics(ctx echo.Context, environment EnvironmentPathParam) error
	// Stream endpoint.
	// (GET /stream)
	Stream(ctx echo.Context, params StreamParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Authenticate converts echo context to params.
func (w *ServerInterfaceWrapper) Authenticate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Authenticate(ctx)
	return err
}

// GetFeatureConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeatureConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFeatureConfig(ctx, environmentUUID)
	return err
}

// GetFeatureConfigByIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeatureConfigByIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	// ------------- Path parameter "identifier" -------------
	var identifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "identifier", runtime.ParamLocationPath, ctx.Param("identifier"), &identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFeatureConfigByIdentifier(ctx, environmentUUID, identifier)
	return err
}

// GetAllSegments converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllSegments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAllSegments(ctx, environmentUUID)
	return err
}

// GetSegmentByIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetSegmentByIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	// ------------- Path parameter "identifier" -------------
	var identifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "identifier", runtime.ParamLocationPath, ctx.Param("identifier"), &identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSegmentByIdentifier(ctx, environmentUUID, identifier)
	return err
}

// GetEvaluations converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvaluations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	// ------------- Path parameter "target" -------------
	var target string

	err = runtime.BindStyledParameterWithLocation("simple", false, "target", runtime.ParamLocationPath, ctx.Param("target"), &target)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEvaluations(ctx, environmentUUID, target)
	return err
}

// GetEvaluationByIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvaluationByIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environmentUUID" -------------
	var environmentUUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "environmentUUID", runtime.ParamLocationPath, ctx.Param("environmentUUID"), &environmentUUID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environmentUUID: %s", err))
	}

	// ------------- Path parameter "target" -------------
	var target string

	err = runtime.BindStyledParameterWithLocation("simple", false, "target", runtime.ParamLocationPath, ctx.Param("target"), &target)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target: %s", err))
	}

	// ------------- Path parameter "feature" -------------
	var feature string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature", runtime.ParamLocationPath, ctx.Param("feature"), &feature)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEvaluationByIdentifier(ctx, environmentUUID, target, feature)
	return err
}

// PostMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) PostMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "environment" -------------
	var environment EnvironmentPathParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "environment", runtime.ParamLocationPath, ctx.Param("environment"), &environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostMetrics(ctx, environment)
	return err
}

// Stream converts echo context to params.
func (w *ServerInterfaceWrapper) Stream(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StreamParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "API-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Key")]; found {
		var APIKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for API-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "API-Key", runtime.ParamLocationHeader, valueList[0], &APIKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter API-Key: %s", err))
		}

		params.APIKey = APIKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter API-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Stream(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/client/auth", wrapper.Authenticate)
	router.GET(baseURL+"/client/env/:environmentUUID/feature-configs", wrapper.GetFeatureConfig)
	router.GET(baseURL+"/client/env/:environmentUUID/feature-configs/:identifier", wrapper.GetFeatureConfigByIdentifier)
	router.GET(baseURL+"/client/env/:environmentUUID/target-segments", wrapper.GetAllSegments)
	router.GET(baseURL+"/client/env/:environmentUUID/target-segments/:identifier", wrapper.GetSegmentByIdentifier)
	router.GET(baseURL+"/client/env/:environmentUUID/target/:target/evaluations", wrapper.GetEvaluations)
	router.GET(baseURL+"/client/env/:environmentUUID/target/:target/evaluations/:feature", wrapper.GetEvaluationByIdentifier)
	router.POST(baseURL+"/metrics/:environment", wrapper.PostMetrics)
	router.GET(baseURL+"/stream", wrapper.Stream)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"wvZu+78AAAD//6hUA//INQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
